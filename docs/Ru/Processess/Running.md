# Класс Running

**Пространство имен:** `z3nCore`

Межпроцессное хранилище в разделяемой памяти для отслеживания запущенных процессов во всех экземплярах ZennoPoster. Все методы потокобезопасны и процессобезопасны благодаря синхронизации через mutex.

**Структура данных:** Каждый процесс хранится как `Dictionary<int, List<object>>` где:
- **Ключ**: Идентификатор процесса (int)
- **Значение**: Список содержащий `[память(МБ), время_работы(минуты), порт, имя_проекта, аккаунт]`

---

## Add

### Назначение
Добавляет или обновляет информацию о процессе в разделяемой памяти.

### Пример
```csharp
int pid = 12345;
var data = new List<object>
{
    150,        // Память в МБ
    5,          // Время работы в минутах
    8080,       // Порт
    "MyProject",// Имя проекта
    "acc123"    // Имя аккаунта
};

Running.Add(pid, data);
Console.WriteLine($"Добавлен процесс {pid} в разделяемое хранилище");
```

### Разбор
```csharp
public static void Add(int pid, List<object> data)
```
- **Параметр `pid`**: Идентификатор процесса для добавления/обновления
- **Параметр `data`**: Список информации о процессе: `[память, время_работы, порт, проект, аккаунт]`
- **Потокобезопасность**: Использует блокировку mutex для межпроцессной синхронизации
- **Перезапись**: Если PID уже существует, данные обновляются
- **Таймаут**: 5 секунд для получения mutex
- **Исключение**: Выбрасывает `TimeoutException` если mutex не может быть получен

---

## Get

### Назначение
Получает информацию о конкретном процессе из разделяемой памяти.

### Пример
```csharp
int pid = 12345;
List<object> data = Running.Get(pid);

if (data != null)
{
    int mem = Convert.ToInt32(data[0]);
    int age = Convert.ToInt32(data[1]);
    int port = Convert.ToInt32(data[2]);
    string proj = data[3].ToString();
    string acc = data[4].ToString();

    Console.WriteLine($"PID {pid}: {acc}, {mem}MB, {age}min, Port:{port}");
}
else
{
    Console.WriteLine($"Процесс {pid} не найден");
}
```

### Разбор
```csharp
public static List<object> Get(int pid)
```
- **Параметр `pid`**: Идентификатор процесса для получения
- **Возвращает**: Список данных о процессе если найден, `null` если не найден
- **Формат данных**: `[память(int), время_работы(int), порт(int), проект(string), аккаунт(string)]`
- **Потокобезопасность**: Использует блокировку mutex
- **Таймаут**: 5 секунд

---

## Remove

### Назначение
Удаляет процесс из разделяемого хранилища.

### Пример
```csharp
int pid = 12345;
bool removed = Running.Remove(pid);

if (removed)
{
    Console.WriteLine($"Процесс {pid} удален из хранилища");
}
else
{
    Console.WriteLine($"Процесс {pid} не найден");
}
```

### Разбор
```csharp
public static bool Remove(int pid)
```
- **Параметр `pid`**: Идентификатор процесса для удаления
- **Возвращает**: `true` если процесс был удален, `false` если не существовал
- **Потокобезопасность**: Использует блокировку mutex
- **Атомарная операция**: Чтение, удаление и запись происходят под одной блокировкой

---

## ContainsKey

### Назначение
Проверяет, существует ли процесс в разделяемом хранилище.

### Пример
```csharp
int pid = 12345;

if (Running.ContainsKey(pid))
{
    Console.WriteLine($"Процесс {pid} отслеживается");
}
else
{
    Console.WriteLine($"Процесс {pid} отсутствует в хранилище");
}
```

### Разбор
```csharp
public static bool ContainsKey(int pid)
```
- **Параметр `pid`**: Идентификатор процесса для проверки
- **Возвращает**: `true` если процесс существует в хранилище, `false` в противном случае
- **Потокобезопасность**: Использует блокировку mutex
- **Быстрая проверка**: Только читает, не модифицирует данные

---

## Clear

### Назначение
Удаляет все процессы из разделяемого хранилища.

### Пример
```csharp
Running.Clear();
Console.WriteLine("Все данные о процессах очищены из разделяемой памяти");

// Проверка
int count = Running.Count;
Console.WriteLine($"Процессов в хранилище: {count}"); // Вывод: 0
```

### Разбор
```csharp
public static void Clear()
```
- **Без параметров**
- **Не возвращает значение**
- **Потокобезопасность**: Использует блокировку mutex
- **Предупреждение**: Это затрагивает все процессы ZennoPoster, использующие ту же память
- **Сценарий использования**: Очистка, тестирование или сброс состояния

---

## Count

### Назначение
Получает общее количество процессов, хранящихся в разделяемой памяти.

### Пример
```csharp
int totalProcesses = Running.Count;
Console.WriteLine($"Всего отслеживаемых процессов: {totalProcesses}");

// Использование в условиях
if (Running.Count > 10)
{
    Console.WriteLine("Предупреждение: Запущено много процессов");
}
```

### Разбор
```csharp
public static int Count { get; }
```
- **Свойство** (только для чтения)
- **Возвращает**: Количество процессов в хранилище
- **Потокобезопасность**: Использует блокировку mutex
- **Производительность**: Загружает все данные для подсчета, рассмотрите кэширование при частых вызовах

---

## ToLocal

### Назначение
Создает локальную копию всех данных о процессах из разделяемой памяти для чтения и анализа. Опционально фильтрует по количеству элементов данных.

### Пример
```csharp
// Получить все процессы
Dictionary<int, List<object>> allProcesses = Running.ToLocal();

foreach (var proc in allProcesses)
{
    int pid = proc.Key;
    var data = proc.Value;
    Console.WriteLine($"PID: {pid}, Элементов данных: {data.Count}");
}

// Получить только процессы с ровно 5 элементами данных
var filtered = Running.ToLocal(dataMembers: 5);
Console.WriteLine($"Процессов с 5 элементами данных: {filtered.Count}");
```

### Разбор
```csharp
public static Dictionary<int, List<object>> ToLocal(int dataMembers = 0)
```
- **Параметр `dataMembers`**: Если `0`, возвращает все процессы. Если > 0, возвращает только процессы с точно таким количеством элементов данных
- **Возвращает**: Копию словаря с данными процессов (безопасно модифицировать локально)
- **Потокобезопасность**: Использует блокировку mutex
- **Сценарий использования**: Анализ данных о процессах без блокировки других процессов
- **Примечание**: Возвращает копию, изменения не повлияют на разделяемую память

---

## FromLocal

### Назначение
Записывает локальный словарь в разделяемую память, полностью заменяя все существующие данные.

### Пример
```csharp
// Получить текущие данные
var local = Running.ToLocal();

// Изменить локально
local.Remove(12345); // Удалить процесс
local[99999] = new List<object> { 100, 10, 8080, "Test", "acc999" }; // Добавить новый

// Записать обратно в разделяемую память
Running.FromLocal(local);
Console.WriteLine("Разделяемая память обновлена измененными данными");
```

### Разбор
```csharp
public static void FromLocal(Dictionary<int, List<object>> localDict)
```
- **Параметр `localDict`**: Словарь для записи в разделяемую память
- **Не возвращает значение**
- **Потокобезопасность**: Использует блокировку mutex
- **Предупреждение**: ПОЛНОСТЬЮ ПЕРЕЗАПИСЫВАЕТ все разделяемые данные
- **Сценарий использования**: Пакетные обновления, восстановление из резервной копии
- **Осторожность**: Это затрагивает все процессы, используйте аккуратно

---

## PruneAndUpdate

### Назначение
Удаляет мертвые процессы и обновляет данные о памяти/времени работы для живых процессов. Это метод обслуживания, который следует вызывать периодически.

### Пример
```csharp
// Добавить несколько процессов
Running.Add(12345, new List<object> { 100, 5, 8080, "Proj1", "acc1" });
Running.Add(99999, new List<object> { 200, 10, 8081, "Proj2", "acc2" });

Console.WriteLine($"До очистки: {Running.Count} процессов");

// Процесс 99999 завершен извне
// ...

// Очистить и обновить
Running.PruneAndUpdate();
Console.WriteLine($"После очистки: {Running.Count} процессов");
// Мертвые процессы удалены, у живых процессов обновлены память/время работы
```

### Разбор
```csharp
public static void PruneAndUpdate()
```
- **Без параметров**
- **Не возвращает значение**
- **Потокобезопасность**: Использует блокировку mutex
- **Выполняемые действия**:
  1. Проверяет каждый сохраненный PID используя `Process.GetProcessById()`
  2. **Мертвые процессы**: Удаляются из хранилища
  3. **Живые процессы**: Обновляются `data[0]` (память) и `data[1]` (время работы в минутах)
  4. Сохраняет `data[2+]` (порт, проект, аккаунт)
- **Сценарий использования**: Периодическая очистка для предотвращения раздувания хранилища
- **Рекомендация**: Вызывайте этот метод регулярно (например, каждые 5-10 секунд)

---

## Dispose

### Назначение
Освобождает дескриптор файла в отображаемой памяти. Следует вызывать при завершении работы приложения.

### Пример
```csharp
// При завершении работы приложения
try
{
    Running.Dispose();
    Console.WriteLine("Ресурсы разделяемой памяти освобождены");
}
catch (Exception ex)
{
    Console.WriteLine($"Ошибка при очистке: {ex.Message}");
}
```

### Разбор
```csharp
public static void Dispose()
```
- **Без параметров**
- **Не возвращает значение**
- **Потокобезопасность**: Использует внутреннюю блокировку
- **Опционально**: ОС очистит при выходе из процесса, но явное освобождение - хорошая практика
- **Идемпотентность**: Безопасно вызывать несколько раз
- **Примечание**: После освобождения следующий доступ повторно откроет файл в отображаемой памяти
- **Сценарий использования**: Завершение работы приложения, очистка в блоках finally

---

## Архитектурные заметки

### Файл в отображаемой памяти (MMF)
- **Имя**: "ZennoRunningProcesses"
- **Размер**: 1 МБ (1024 * 1024 байт)
- **Формат**: Первые 4 байта = длина данных, остальные байты = UTF-8 JSON
- **Разделяемость**: Доступен всем экземплярам процессов ZennoPoster

### Синхронизация через Mutex
- **Имя**: "ZennoRunningProcessesMutex"
- **Таймаут**: 5 секунд
- **Назначение**: Предотвращает условия гонки при доступе нескольких процессов к разделяемой памяти
- **Ошибка**: `TimeoutException` если блокировка не может быть получена (указывает на взаимную блокировку или зависший процесс)

### Сохранность данных
- **Время жизни**: Данные сохраняются пока любой процесс держит ссылку на MMF
- **Выживание**: Переживает крахи отдельных процессов
- **Сброс**: Очищается только явным вызовом `Clear()` или перезагрузкой системы

### Лучшие практики
1. **Вызывайте `PruneAndUpdate()` регулярно** для удаления мертвых процессов
2. **Используйте `ToLocal()` для операций с большим количеством чтений** чтобы минимизировать время блокировки
3. **Держите размер данных небольшим** (лимит 1 МБ для всех процессов)
4. **Обрабатывайте `TimeoutException`** во всех операциях
5. **Вызывайте `Dispose()` при завершении приложения** (опционально, но рекомендуется)
